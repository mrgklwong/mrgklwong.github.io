{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Hi, I'm Ka Lee Gary Wong I am a QA Architect based in London. A Little About Me I graduated with a degree in Computer Games, and since then I have accumulated 20 years of QA knowledge and industry experiences. I have a big fan of lofi, syncwave, retro gaming. I will always have a pair of ear buds or headphones on, listening to whichever wuxia or fantasy novel I have at the time. Like some I never had a goal in life. But my tao seems to be QA related. My Tao My Tao is to help create, plan and improve QA processes with a wide set of skills including programming, engineering resourcing, team budgeting and solution design for the team/business in question. I actively try to help and mentor more junior members within QA to improve and will either sponsor or direct in the right direction. And in turn I learn, grow and traverse my tao. Contact Contact Me \ud83d\udce7 mrgarywong@duck.com https://www.linkedin.com/in/ka-lee-gary-wong-13336313","title":"Home"},{"location":"#hi-im-ka-lee-gary-wong","text":"I am a QA Architect based in London.","title":"Hi, I'm Ka Lee Gary Wong"},{"location":"#a-little-about-me","text":"I graduated with a degree in Computer Games, and since then I have accumulated 20 years of QA knowledge and industry experiences. I have a big fan of lofi, syncwave, retro gaming. I will always have a pair of ear buds or headphones on, listening to whichever wuxia or fantasy novel I have at the time. Like some I never had a goal in life. But my tao seems to be QA related.","title":"A Little About Me"},{"location":"#my-tao","text":"My Tao is to help create, plan and improve QA processes with a wide set of skills including programming, engineering resourcing, team budgeting and solution design for the team/business in question. I actively try to help and mentor more junior members within QA to improve and will either sponsor or direct in the right direction. And in turn I learn, grow and traverse my tao.","title":"My Tao"},{"location":"#contact","text":"Contact Me \ud83d\udce7 mrgarywong@duck.com https://www.linkedin.com/in/ka-lee-gary-wong-13336313","title":"Contact"},{"location":"blog/","text":"Profile Polyglot Technologist with a specialisation in Quality Engineering. During my career path I've helped teams and organisations define, implement and expand what quality looks like within the organisation Curriculum Vitae Global Logic UK & I, A Hitachi Group Company","title":"Profile"},{"location":"blog/#profile","text":"Polyglot Technologist with a specialisation in Quality Engineering. During my career path I've helped teams and organisations define, implement and expand what quality looks like within the organisation","title":"Profile"},{"location":"blog/#curriculum-vitae","text":"Global Logic UK & I, A Hitachi Group Company","title":"Curriculum Vitae"},{"location":"frameworks/","text":"Frameworks and Projects Playwright Based Frameworks Playwright UI Testing framework TS Playwright API Testing framework TS Playwright Accessibility Testing framework TS IAC Testing Testing Terraform using TerraTest","title":"Frameworks"},{"location":"frameworks/#frameworks-and-projects","text":"Playwright Based Frameworks Playwright UI Testing framework TS Playwright API Testing framework TS Playwright Accessibility Testing framework TS IAC Testing Testing Terraform using TerraTest","title":"Frameworks and Projects"},{"location":"playwright-ts-accessibility/","text":"Playwright TS Accessibility Framework As mentioned in the TS UI framework page, playwright is featured packed. On this page we demo the Accessibility feature of the framework. Getting Started Step 1. Follow the setup on the UI page Step 2. Import to the existing test file the following axe-core library import AxeBuilder from '@axe-core/playwright' Step 3. Configure you rule tags and exclusions. Step 4. Use the AxeBuilder functions to analyze the code. Simple right? Here's an example // importing playwright and axebuilder for the test import {test, expect} from '@playwright/test'; import AxeBuilder from '@axe-core/playwright'; test.describe('Testing', () => { test('should not have any automatically detectable accessibility issues', async ({ page }) => { // Set up the test for site under test await page.goto('https://your-site.com/'); // Set up the axebuilder to use the site, with tags const accessibilityScanResults = await new AxeBuilder({ page }) .withTags(['wcag2a', 'wcag2aa', 'wcag21a', 'wcag21aa']) .analyze(); // Add in a test to expect something from the results. expect(accessibilityScanResults.violations).toEqual([]); }); }); Conclusion Simple 3 ish extra lines to a current playwright scripts will allow the additional accessibility functions. Try it out!","title":"Playwright TS Accessibility Framework"},{"location":"playwright-ts-accessibility/#playwright-ts-accessibility-framework","text":"As mentioned in the TS UI framework page, playwright is featured packed. On this page we demo the Accessibility feature of the framework.","title":"Playwright TS Accessibility Framework"},{"location":"playwright-ts-accessibility/#getting-started","text":"Step 1. Follow the setup on the UI page Step 2. Import to the existing test file the following axe-core library import AxeBuilder from '@axe-core/playwright' Step 3. Configure you rule tags and exclusions. Step 4. Use the AxeBuilder functions to analyze the code. Simple right? Here's an example // importing playwright and axebuilder for the test import {test, expect} from '@playwright/test'; import AxeBuilder from '@axe-core/playwright'; test.describe('Testing', () => { test('should not have any automatically detectable accessibility issues', async ({ page }) => { // Set up the test for site under test await page.goto('https://your-site.com/'); // Set up the axebuilder to use the site, with tags const accessibilityScanResults = await new AxeBuilder({ page }) .withTags(['wcag2a', 'wcag2aa', 'wcag21a', 'wcag21aa']) .analyze(); // Add in a test to expect something from the results. expect(accessibilityScanResults.violations).toEqual([]); }); });","title":"Getting Started"},{"location":"playwright-ts-accessibility/#conclusion","text":"Simple 3 ish extra lines to a current playwright scripts will allow the additional accessibility functions. Try it out!","title":"Conclusion"},{"location":"playwright-ts-api/","text":"Playwright TS API Framework As mentioned in the TS UI framework page, playwright is featured packed. On this page we demo the API feature of the framework. Set Up. Step 1. Follow the setup on the UI page Step 2. Open the playwright.config.ts file and updated the baseURL to the api test endpoint. Add in headers too. Example baseURL: 'https://example.apiendpoint.io', extraHTTPHeaders: { // We set this header per GitHub guidelines. 'Accept': 'application/json' // Add authorization token to all requests. // Assuming personal access token available in the environment. }, Step 3. Create a new test.spec.ts file Step 4. Open the file add in the imports. The main testing library @playwright/test import {expect, test} from '@playwright/test'; Step 5. Start creating tests. :) Basic test breakdown will look like the following code block: test('Some title',async ({request}) => { // Sets up the Title, makes a async function using request. const response = await request.get('/some endpoint'); // Acts Makes a get call with the request and sets it to response expect(response.ok()).toBeTruthy(); // Asserts Tests on the response }); Cheatsheet Use this cheatsheet to help with your tests. Code Description request.post('endpoint', { } API POST call request.get('endpoint') API GET call request.put('endpoint', { } API PUT call request.delete('endpoint', { } API DELETE call const validate = require('jsonschema').validate; Creates a const validate to be used for schema validation const schema = await new URL('https://example/schema.json'); Get the schema from the URL expect(validate(response, schema)).toBeTruthy(); Using the validate and schema to check on the response An example of api framework can be found here More information can be found on the official site . Conclusion Playwright API testing is simple to set up, and has all the usual api testing features required. Using the test.beforeAll will allow data creation needed for the API test. But is it needed? Playwright has fixtures which we will use in place of before.test. I will be exploring fixtures in another demo.","title":"Playwright TS API Framework"},{"location":"playwright-ts-api/#playwright-ts-api-framework","text":"As mentioned in the TS UI framework page, playwright is featured packed. On this page we demo the API feature of the framework.","title":"Playwright TS API Framework"},{"location":"playwright-ts-api/#set-up","text":"Step 1. Follow the setup on the UI page Step 2. Open the playwright.config.ts file and updated the baseURL to the api test endpoint. Add in headers too. Example baseURL: 'https://example.apiendpoint.io', extraHTTPHeaders: { // We set this header per GitHub guidelines. 'Accept': 'application/json' // Add authorization token to all requests. // Assuming personal access token available in the environment. }, Step 3. Create a new test.spec.ts file Step 4. Open the file add in the imports. The main testing library @playwright/test import {expect, test} from '@playwright/test'; Step 5. Start creating tests. :) Basic test breakdown will look like the following code block: test('Some title',async ({request}) => { // Sets up the Title, makes a async function using request. const response = await request.get('/some endpoint'); // Acts Makes a get call with the request and sets it to response expect(response.ok()).toBeTruthy(); // Asserts Tests on the response });","title":"Set Up."},{"location":"playwright-ts-api/#cheatsheet","text":"Use this cheatsheet to help with your tests. Code Description request.post('endpoint', { } API POST call request.get('endpoint') API GET call request.put('endpoint', { } API PUT call request.delete('endpoint', { } API DELETE call const validate = require('jsonschema').validate; Creates a const validate to be used for schema validation const schema = await new URL('https://example/schema.json'); Get the schema from the URL expect(validate(response, schema)).toBeTruthy(); Using the validate and schema to check on the response An example of api framework can be found here More information can be found on the official site .","title":"Cheatsheet"},{"location":"playwright-ts-api/#conclusion","text":"Playwright API testing is simple to set up, and has all the usual api testing features required. Using the test.beforeAll will allow data creation needed for the API test. But is it needed? Playwright has fixtures which we will use in place of before.test. I will be exploring fixtures in another demo.","title":"Conclusion"},{"location":"playwright-ts/","text":"Playwright TS UI Framework Developed by Microsoft, Playwright is a relatively new open source testing frameworks which has been gaining popularity since its release in Feb 2020. Although this page is focused on the TS UI side of the framework it handles much more, include accessibility, components and tracing. Playwright currently supports JS/TS, Java, Python and .Net In this page, I will demo the easy step of the framework Getting Started Download and install node for you OS Windows - Download the node from the node site https://nodejs.org/dist/v18.12.1/node-v18.12.1-x64.msi Mac (using homebrew) /bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\" brew install node Create a new folder Inside the new folder install playwright npm init playwright@latest , follow the defaults prompts This will create the following files in the folder: playwright.config.ts package.json package-lock.json tests/ example.spec.ts tests-examples/ demo-todo-app.spec.ts And that's it! Or you can clone the example repo located here Conclusion The devs at Playwright have done loads to make starting easy. In less than 4 steps a SDET can start providing value with this new framework. The framework packed full of features including: Support of the latest browser Build in Video and Screenshot capture API testing and Mocking Authentication handling using sessions Test Generations for the lazy coder Accessibility Testing Support of POM design patten Built in retry, timeout and reporters. Ability to use selenium grid testing infra. So far the only downside of the framework I have noticed is the lack of backward browser compatibility. I might be able to find more. But I hope workarounds can be found. I will be exploring some of these features in other framework pages.","title":"Playwright TS UI Framework"},{"location":"playwright-ts/#playwright-ts-ui-framework","text":"Developed by Microsoft, Playwright is a relatively new open source testing frameworks which has been gaining popularity since its release in Feb 2020. Although this page is focused on the TS UI side of the framework it handles much more, include accessibility, components and tracing. Playwright currently supports JS/TS, Java, Python and .Net In this page, I will demo the easy step of the framework","title":"Playwright TS UI Framework"},{"location":"playwright-ts/#getting-started","text":"Download and install node for you OS Windows - Download the node from the node site https://nodejs.org/dist/v18.12.1/node-v18.12.1-x64.msi Mac (using homebrew) /bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\" brew install node Create a new folder Inside the new folder install playwright npm init playwright@latest , follow the defaults prompts This will create the following files in the folder: playwright.config.ts package.json package-lock.json tests/ example.spec.ts tests-examples/ demo-todo-app.spec.ts And that's it! Or you can clone the example repo located here","title":"Getting Started"},{"location":"playwright-ts/#conclusion","text":"The devs at Playwright have done loads to make starting easy. In less than 4 steps a SDET can start providing value with this new framework. The framework packed full of features including: Support of the latest browser Build in Video and Screenshot capture API testing and Mocking Authentication handling using sessions Test Generations for the lazy coder Accessibility Testing Support of POM design patten Built in retry, timeout and reporters. Ability to use selenium grid testing infra. So far the only downside of the framework I have noticed is the lack of backward browser compatibility. I might be able to find more. But I hope workarounds can be found. I will be exploring some of these features in other framework pages.","title":"Conclusion"},{"location":"profile/","text":"Profile Polyglot Technologist with a specialisation in Quality Engineering. During my career path I've helped teams and organisations define, implement and expand what quality looks like within the organisation Over the span for my career I have worked with a host of QE technologies. Curriculum Vitae Jan 2020 - Current Global Logic UK & I, A Hitachi Group Company Title Delivery Consultant Description Working as QA Test Architect on a number of projects across domains, which including Banking and Finance. The work covered the creation frameworks to providing a 6 month QE improvement roadmap Apr 2019 - Jan 2020 Beamery Title Senior QA Engineer Description Developed and Orchestrated the Performance Testing Strategy, gathering NFRs and established the NFT. The role also included engineering management responsibilities, including interviewing, mentoring and defining QA roadmaps. Aug 2017 - Apr 2019 Karhoo Title Automation Test Lead Description Usual start up type role. Did everything, from Full stack testing implementation to pipeline and CICD and testing Infrastructure configuration. Also helped expand the QA team Sep 2015 - Aug 2017 Digitas UK Title Test Automation Engineer (Contract) Description Working on the AEM digital platform which ran a cross continent motor showcase website. I was in charge of the Automation sprint, which included sizing, planning and increasing the test case coverage Feb 2015 - Sep 2017 net-a-porter Title Developer In Test (Contract) Description Expanded the API and Backend test scope, which included in sprint activities for a legacy mono repo and the new microservices the team was switching over to at the time. Nov 2013 - Jan 2015 Collinson Group Title Senior Mobile Automation QA Developer (Contract) Description The Collinson group needed to change the old manual testing regression into something they could run on the CICD pipeline. I helped plan and implement it. I also helped more junior members to learn the framework and general QA process Oct 2013 - Nov 2013 Smooch.com Title Software Developer in Test (Contract) Description Create and planned the automation test strategy and roadmap for the next 6 month, leveraging the CICD pipelines May 2012 - Oct 2013 Kurt Geiger Title Automation QA Tester Description Working on 5 different LAMP sites. I used Gherkin BDD, whilst working with the UX team to develop user stories based on the designs. I would then use them for automation and manual tests Apr 2010 - Jan 2012 ITV Title Automation QA Tester Description Working on 5 different LAMP sites. I used Gherkin BDD, whilst working with the UX team to develop user stories based on the designs. I would then use them for automation and manual tests Aug 2008 - Apr 2010 HMV Title QA Tester Description Working on the green screen checkout system AS400. Mainframe automation and testing. Pretty Old skool. Did loads of test plans and test case creation. Worked along side SME to do regression May 2006 - Aug 2008 Playwize Title QA Tester Description Testing a poker software. This involved loads of betting and ensuring the poker stats was correct.","title":"Profile"},{"location":"profile/#profile","text":"Polyglot Technologist with a specialisation in Quality Engineering. During my career path I've helped teams and organisations define, implement and expand what quality looks like within the organisation Over the span for my career I have worked with a host of QE technologies.","title":"Profile"},{"location":"profile/#curriculum-vitae","text":"Jan 2020 - Current Global Logic UK & I, A Hitachi Group Company Title Delivery Consultant Description Working as QA Test Architect on a number of projects across domains, which including Banking and Finance. The work covered the creation frameworks to providing a 6 month QE improvement roadmap Apr 2019 - Jan 2020 Beamery Title Senior QA Engineer Description Developed and Orchestrated the Performance Testing Strategy, gathering NFRs and established the NFT. The role also included engineering management responsibilities, including interviewing, mentoring and defining QA roadmaps. Aug 2017 - Apr 2019 Karhoo Title Automation Test Lead Description Usual start up type role. Did everything, from Full stack testing implementation to pipeline and CICD and testing Infrastructure configuration. Also helped expand the QA team Sep 2015 - Aug 2017 Digitas UK Title Test Automation Engineer (Contract) Description Working on the AEM digital platform which ran a cross continent motor showcase website. I was in charge of the Automation sprint, which included sizing, planning and increasing the test case coverage Feb 2015 - Sep 2017 net-a-porter Title Developer In Test (Contract) Description Expanded the API and Backend test scope, which included in sprint activities for a legacy mono repo and the new microservices the team was switching over to at the time. Nov 2013 - Jan 2015 Collinson Group Title Senior Mobile Automation QA Developer (Contract) Description The Collinson group needed to change the old manual testing regression into something they could run on the CICD pipeline. I helped plan and implement it. I also helped more junior members to learn the framework and general QA process Oct 2013 - Nov 2013 Smooch.com Title Software Developer in Test (Contract) Description Create and planned the automation test strategy and roadmap for the next 6 month, leveraging the CICD pipelines May 2012 - Oct 2013 Kurt Geiger Title Automation QA Tester Description Working on 5 different LAMP sites. I used Gherkin BDD, whilst working with the UX team to develop user stories based on the designs. I would then use them for automation and manual tests Apr 2010 - Jan 2012 ITV Title Automation QA Tester Description Working on 5 different LAMP sites. I used Gherkin BDD, whilst working with the UX team to develop user stories based on the designs. I would then use them for automation and manual tests Aug 2008 - Apr 2010 HMV Title QA Tester Description Working on the green screen checkout system AS400. Mainframe automation and testing. Pretty Old skool. Did loads of test plans and test case creation. Worked along side SME to do regression May 2006 - Aug 2008 Playwize Title QA Tester Description Testing a poker software. This involved loads of betting and ensuring the poker stats was correct.","title":"Curriculum Vitae"},{"location":"terratest/","text":"Terratest, Testing Deployments Terratest is a Go library that provides patterns and helper functions for testing infrastructure, with 1st-class support for Terraform, Packer, Docker, Kubernetes, AWS, GCP, and more. Created by gruntwork.io, the team behind terragrunt. In this page, I will demo the easy step of the framework, following the instructions on the quick-start Getting Started Download and install go lang (mac) and terraform using brew Mac (using homebrew) brew install go brew install terraform Create a new folders example and test Inside the new example folder copy the files from this directory The output of this step should look like this: example/ main.tf output.tf varfile.tfvars example.spec.ts variables.tf Inside the new test folder create file called terraform_basic_example_test.go with the following contents: package test import ( \"testing\" \"github.com/gruntwork-io/terratest/modules/terraform\" \"github.com/stretchr/testify/assert\" ) // An example of how to test the simple Terraform module in examples/terraform-basic-example using Terratest. func TestTerraformBasicExample(t *testing.T) { t.Parallel() expectedText := \"test\" expectedList := []string{expectedText} expectedMap := map[string]string{\"expected\": expectedText} terraformOptions := terraform.WithDefaultRetryableErrors(t, &terraform.Options{ // website::tag::1::Set the path to the Terraform code that will be tested. // The path to where our Terraform code is located TerraformDir: \"../examples\", // Variables to pass to our Terraform code using -var options Vars: map[string]interface{}{ \"example\": expectedText, // We also can see how lists and maps translate between terratest and terraform. \"example_list\": expectedList, \"example_map\": expectedMap, }, // Variables to pass to our Terraform code using -var-file options VarFiles: []string{\"varfile.tfvars\"}, // Disable colors in Terraform commands so its easier to parse stdout/stderr NoColor: true, }) // website::tag::4::Clean up resources with \"terraform destroy\". Using \"defer\" runs the command at the end of the test, whether the test succeeds or fails. // At the end of the test, run `terraform destroy` to clean up any resources that were created defer terraform.Destroy(t, terraformOptions) // website::tag::2::Run \"terraform init\" and \"terraform apply\". // This will run `terraform init` and `terraform apply` and fail the test if there are any errors terraform.InitAndApply(t, terraformOptions) // Run `terraform output` to get the values of output variables actualTextExample := terraform.Output(t, terraformOptions, \"example\") actualTextExample2 := terraform.Output(t, terraformOptions, \"example2\") actualExampleList := terraform.OutputList(t, terraformOptions, \"example_list\") actualExampleMap := terraform.OutputMap(t, terraformOptions, \"example_map\") // website::tag::3::Check the output against expected values. // Verify we're getting back the outputs we expect assert.Equal(t, expectedText, actualTextExample) assert.Equal(t, expectedText, actualTextExample2) assert.Equal(t, expectedList, actualExampleList) assert.Equal(t, expectedMap, actualExampleMap) } Install the go deps cd test go mod init test go mod tidy Run the tests! Hopefully when the test will run the output of the terminal will end with --- PASS: TestTerraformBasicExample (0.80s) PASS ok command-line-arguments 1.312s Conclusion As QA within Devops, it helps to have a framework that can validated Infrastructure as code (IAC). In my mind having pr validating with terratest stops the checkin of broken terraform code. It uses Go Lang, which new SDETSs will welcome the challenge, compare to the normal js/java/python most SDETs know. I will explore other IAC testing frameworks, in other posts.","title":"Terratest, Testing Deployments"},{"location":"terratest/#terratest-testing-deployments","text":"Terratest is a Go library that provides patterns and helper functions for testing infrastructure, with 1st-class support for Terraform, Packer, Docker, Kubernetes, AWS, GCP, and more. Created by gruntwork.io, the team behind terragrunt. In this page, I will demo the easy step of the framework, following the instructions on the quick-start","title":"Terratest, Testing Deployments"},{"location":"terratest/#getting-started","text":"Download and install go lang (mac) and terraform using brew Mac (using homebrew) brew install go brew install terraform Create a new folders example and test Inside the new example folder copy the files from this directory The output of this step should look like this: example/ main.tf output.tf varfile.tfvars example.spec.ts variables.tf Inside the new test folder create file called terraform_basic_example_test.go with the following contents: package test import ( \"testing\" \"github.com/gruntwork-io/terratest/modules/terraform\" \"github.com/stretchr/testify/assert\" ) // An example of how to test the simple Terraform module in examples/terraform-basic-example using Terratest. func TestTerraformBasicExample(t *testing.T) { t.Parallel() expectedText := \"test\" expectedList := []string{expectedText} expectedMap := map[string]string{\"expected\": expectedText} terraformOptions := terraform.WithDefaultRetryableErrors(t, &terraform.Options{ // website::tag::1::Set the path to the Terraform code that will be tested. // The path to where our Terraform code is located TerraformDir: \"../examples\", // Variables to pass to our Terraform code using -var options Vars: map[string]interface{}{ \"example\": expectedText, // We also can see how lists and maps translate between terratest and terraform. \"example_list\": expectedList, \"example_map\": expectedMap, }, // Variables to pass to our Terraform code using -var-file options VarFiles: []string{\"varfile.tfvars\"}, // Disable colors in Terraform commands so its easier to parse stdout/stderr NoColor: true, }) // website::tag::4::Clean up resources with \"terraform destroy\". Using \"defer\" runs the command at the end of the test, whether the test succeeds or fails. // At the end of the test, run `terraform destroy` to clean up any resources that were created defer terraform.Destroy(t, terraformOptions) // website::tag::2::Run \"terraform init\" and \"terraform apply\". // This will run `terraform init` and `terraform apply` and fail the test if there are any errors terraform.InitAndApply(t, terraformOptions) // Run `terraform output` to get the values of output variables actualTextExample := terraform.Output(t, terraformOptions, \"example\") actualTextExample2 := terraform.Output(t, terraformOptions, \"example2\") actualExampleList := terraform.OutputList(t, terraformOptions, \"example_list\") actualExampleMap := terraform.OutputMap(t, terraformOptions, \"example_map\") // website::tag::3::Check the output against expected values. // Verify we're getting back the outputs we expect assert.Equal(t, expectedText, actualTextExample) assert.Equal(t, expectedText, actualTextExample2) assert.Equal(t, expectedList, actualExampleList) assert.Equal(t, expectedMap, actualExampleMap) } Install the go deps cd test go mod init test go mod tidy Run the tests! Hopefully when the test will run the output of the terminal will end with --- PASS: TestTerraformBasicExample (0.80s) PASS ok command-line-arguments 1.312s","title":"Getting Started"},{"location":"terratest/#conclusion","text":"As QA within Devops, it helps to have a framework that can validated Infrastructure as code (IAC). In my mind having pr validating with terratest stops the checkin of broken terraform code. It uses Go Lang, which new SDETSs will welcome the challenge, compare to the normal js/java/python most SDETs know. I will explore other IAC testing frameworks, in other posts.","title":"Conclusion"}]}